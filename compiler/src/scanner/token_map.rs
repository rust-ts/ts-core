use once_cell::sync::OnceCell;
use phf::{phf_map, Map};

use crate::types::SyntaxKinds;

static STR_TO_KEYWORD: Map<&'static str, u16> = phf_map! {
  "abstract" => SyntaxKinds::AbstractKeyword,
  "any" => SyntaxKinds::AnyKeyword,
  "as" => SyntaxKinds::AsKeyword,
  "asserts" => SyntaxKinds::AssertsKeyword,
  "bigint" => SyntaxKinds::BigIntKeyword,
  "boolean" => SyntaxKinds::BooleanKeyword,
  "break" => SyntaxKinds::BreakKeyword,
  "case" => SyntaxKinds::CaseKeyword,
  "catch" => SyntaxKinds::CatchKeyword,
  "class" => SyntaxKinds::ClassKeyword,
  "continue" => SyntaxKinds::ContinueKeyword,
  "const" => SyntaxKinds::ConstKeyword,
  "constructor" => SyntaxKinds::ConstructorKeyword,
  "debugger" => SyntaxKinds::DebuggerKeyword,
  "declare" => SyntaxKinds::DeclareKeyword,
  "default" => SyntaxKinds::DefaultKeyword,
  "delete" => SyntaxKinds::DeleteKeyword,
  "do" => SyntaxKinds::DoKeyword,
  "else" => SyntaxKinds::ElseKeyword,
  "enum" => SyntaxKinds::EnumKeyword,
  "export" => SyntaxKinds::ExportKeyword,
  "extends" => SyntaxKinds::ExtendsKeyword,
  "false" => SyntaxKinds::FalseKeyword,
  "finally" => SyntaxKinds::FinallyKeyword,
  "for" => SyntaxKinds::ForKeyword,
  "from" => SyntaxKinds::FromKeyword,
  "function" => SyntaxKinds::FunctionKeyword,
  "get" => SyntaxKinds::GetKeyword,
  "if" => SyntaxKinds::IfKeyword,
  "implements" => SyntaxKinds::ImplementsKeyword,
  "import" => SyntaxKinds::ImportKeyword,
  "in" => SyntaxKinds::InKeyword,
  "infer" => SyntaxKinds::InferKeyword,
  "instanceof" => SyntaxKinds::InstanceOfKeyword,
  "interface" => SyntaxKinds::InterfaceKeyword,
  "is" => SyntaxKinds::IsKeyword,
  "keyof" => SyntaxKinds::KeyOfKeyword,
  "let" => SyntaxKinds::LetKeyword,
  "module" => SyntaxKinds::ModuleKeyword,
  "namespace" => SyntaxKinds::NamespaceKeyword,
  "never" => SyntaxKinds::NeverKeyword,
  "new" => SyntaxKinds::NewKeyword,
  "null" => SyntaxKinds::NullKeyword,
  "number" => SyntaxKinds::NumberKeyword,
  "object" => SyntaxKinds::ObjectKeyword,
  "package" => SyntaxKinds::PackageKeyword,
  "private" => SyntaxKinds::PrivateKeyword,
  "protected" => SyntaxKinds::ProtectedKeyword,
  "public" => SyntaxKinds::PublicKeyword,
  "readonly" => SyntaxKinds::ReadonlyKeyword,
  "require" => SyntaxKinds::RequireKeyword,
  "global" => SyntaxKinds::GlobalKeyword,
  "return" => SyntaxKinds::ReturnKeyword,
  "set" => SyntaxKinds::SetKeyword,
  "static" => SyntaxKinds::StaticKeyword,
  "string" => SyntaxKinds::StringKeyword,
  "super" => SyntaxKinds::SuperKeyword,
  "switch" => SyntaxKinds::SwitchKeyword,
  "symbol" => SyntaxKinds::SymbolKeyword,
  "this" => SyntaxKinds::ThisKeyword,
  "throw" => SyntaxKinds::ThrowKeyword,
  "true" => SyntaxKinds::TrueKeyword,
  "try" => SyntaxKinds::TryKeyword,
  "type" => SyntaxKinds::TypeKeyword,
  "typeof" => SyntaxKinds::TypeOfKeyword,
  "undefined" => SyntaxKinds::UndefinedKeyword,
  "unique" => SyntaxKinds::UniqueKeyword,
  "unknown" => SyntaxKinds::UnknownKeyword,
  "var" => SyntaxKinds::VarKeyword,
  "void" => SyntaxKinds::VoidKeyword,
  "while" => SyntaxKinds::WhileKeyword,
  "with" => SyntaxKinds::WithKeyword,
  "yield" => SyntaxKinds::YieldKeyword,
  "async" => SyntaxKinds::AsyncKeyword,
  "await" => SyntaxKinds::AwaitKeyword,
  "of" => SyntaxKinds::OfKeyword,
};
static STR_TO_TOKEN: Map<&'static str, u16> = phf_map! {
  "abstract" => SyntaxKinds::AbstractKeyword,
  "any" => SyntaxKinds::AnyKeyword,
  "as" => SyntaxKinds::AsKeyword,
  "asserts" => SyntaxKinds::AssertsKeyword,
  "bigint" => SyntaxKinds::BigIntKeyword,
  "boolean" => SyntaxKinds::BooleanKeyword,
  "break" => SyntaxKinds::BreakKeyword,
  "case" => SyntaxKinds::CaseKeyword,
  "catch" => SyntaxKinds::CatchKeyword,
  "class" => SyntaxKinds::ClassKeyword,
  "continue" => SyntaxKinds::ContinueKeyword,
  "const" => SyntaxKinds::ConstKeyword,
  "constructor" => SyntaxKinds::ConstructorKeyword,
  "debugger" => SyntaxKinds::DebuggerKeyword,
  "declare" => SyntaxKinds::DeclareKeyword,
  "default" => SyntaxKinds::DefaultKeyword,
  "delete" => SyntaxKinds::DeleteKeyword,
  "do" => SyntaxKinds::DoKeyword,
  "else" => SyntaxKinds::ElseKeyword,
  "enum" => SyntaxKinds::EnumKeyword,
  "export" => SyntaxKinds::ExportKeyword,
  "extends" => SyntaxKinds::ExtendsKeyword,
  "false" => SyntaxKinds::FalseKeyword,
  "finally" => SyntaxKinds::FinallyKeyword,
  "for" => SyntaxKinds::ForKeyword,
  "from" => SyntaxKinds::FromKeyword,
  "function" => SyntaxKinds::FunctionKeyword,
  "get" => SyntaxKinds::GetKeyword,
  "if" => SyntaxKinds::IfKeyword,
  "implements" => SyntaxKinds::ImplementsKeyword,
  "import" => SyntaxKinds::ImportKeyword,
  "in" => SyntaxKinds::InKeyword,
  "infer" => SyntaxKinds::InferKeyword,
  "instanceof" => SyntaxKinds::InstanceOfKeyword,
  "interface" => SyntaxKinds::InterfaceKeyword,
  "is" => SyntaxKinds::IsKeyword,
  "keyof" => SyntaxKinds::KeyOfKeyword,
  "let" => SyntaxKinds::LetKeyword,
  "module" => SyntaxKinds::ModuleKeyword,
  "namespace" => SyntaxKinds::NamespaceKeyword,
  "never" => SyntaxKinds::NeverKeyword,
  "new" => SyntaxKinds::NewKeyword,
  "null" => SyntaxKinds::NullKeyword,
  "number" => SyntaxKinds::NumberKeyword,
  "object" => SyntaxKinds::ObjectKeyword,
  "package" => SyntaxKinds::PackageKeyword,
  "private" => SyntaxKinds::PrivateKeyword,
  "protected" => SyntaxKinds::ProtectedKeyword,
  "public" => SyntaxKinds::PublicKeyword,
  "readonly" => SyntaxKinds::ReadonlyKeyword,
  "require" => SyntaxKinds::RequireKeyword,
  "global" => SyntaxKinds::GlobalKeyword,
  "return" => SyntaxKinds::ReturnKeyword,
  "set" => SyntaxKinds::SetKeyword,
  "static" => SyntaxKinds::StaticKeyword,
  "string" => SyntaxKinds::StringKeyword,
  "super" => SyntaxKinds::SuperKeyword,
  "switch" => SyntaxKinds::SwitchKeyword,
  "symbol" => SyntaxKinds::SymbolKeyword,
  "this" => SyntaxKinds::ThisKeyword,
  "throw" => SyntaxKinds::ThrowKeyword,
  "true" => SyntaxKinds::TrueKeyword,
  "try" => SyntaxKinds::TryKeyword,
  "type" => SyntaxKinds::TypeKeyword,
  "typeof" => SyntaxKinds::TypeOfKeyword,
  "undefined" => SyntaxKinds::UndefinedKeyword,
  "unique" => SyntaxKinds::UniqueKeyword,
  "unknown" => SyntaxKinds::UnknownKeyword,
  "var" => SyntaxKinds::VarKeyword,
  "void" => SyntaxKinds::VoidKeyword,
  "while" => SyntaxKinds::WhileKeyword,
  "with" => SyntaxKinds::WithKeyword,
  "yield" => SyntaxKinds::YieldKeyword,
  "async" => SyntaxKinds::AsyncKeyword,
  "await" => SyntaxKinds::AwaitKeyword,
  "of" => SyntaxKinds::OfKeyword,

  "{" => SyntaxKinds::OpenBraceToken,
  "}" => SyntaxKinds::CloseBraceToken,
  "(" => SyntaxKinds::OpenParenToken,
  ")" => SyntaxKinds::CloseParenToken,
  "[" => SyntaxKinds::OpenBracketToken,
  "]" => SyntaxKinds::CloseBracketToken,
  "." => SyntaxKinds::DotToken,
  "..." => SyntaxKinds::DotDotDotToken,
  ";" => SyntaxKinds::SemicolonToken,
  "," => SyntaxKinds::CommaToken,
  "<" => SyntaxKinds::LessThanToken,
  ">" => SyntaxKinds::GreaterThanToken,
  "<=" => SyntaxKinds::LessThanEqualsToken,
  ">=" => SyntaxKinds::GreaterThanEqualsToken,
  "==" => SyntaxKinds::EqualsEqualsToken,
  "!=" => SyntaxKinds::ExclamationEqualsToken,
  "===" => SyntaxKinds::EqualsEqualsEqualsToken,
  "!==" => SyntaxKinds::ExclamationEqualsEqualsToken,
  "=>" => SyntaxKinds::EqualsGreaterThanToken,
  "+" => SyntaxKinds::PlusToken,
  "-" => SyntaxKinds::MinusToken,
  "**" => SyntaxKinds::AsteriskAsteriskToken,
  "*" => SyntaxKinds::AsteriskToken,
  "/" => SyntaxKinds::SlashToken,
  "%" => SyntaxKinds::PercentToken,
  "++" => SyntaxKinds::PlusPlusToken,
  "--" => SyntaxKinds::MinusMinusToken,
  "<<" => SyntaxKinds::LessThanLessThanToken,
  "</" => SyntaxKinds::LessThanSlashToken,
  ">>" => SyntaxKinds::GreaterThanGreaterThanToken,
  ">>>" => SyntaxKinds::GreaterThanGreaterThanGreaterThanToken,
  "&" => SyntaxKinds::AmpersandToken,
  "|" => SyntaxKinds::BarToken,
  "^" => SyntaxKinds::CaretToken,
  "!" => SyntaxKinds::ExclamationToken,
  "~" => SyntaxKinds::TildeToken,
  "&&" => SyntaxKinds::AmpersandAmpersandToken,
  "||" => SyntaxKinds::BarBarToken,
  "?" => SyntaxKinds::QuestionToken,
  "??" => SyntaxKinds::QuestionQuestionToken,
  "?." => SyntaxKinds::QuestionDotToken,
  ":" => SyntaxKinds::ColonToken,
  "=" => SyntaxKinds::EqualsToken,
  "+=" => SyntaxKinds::PlusEqualsToken,
  "-=" => SyntaxKinds::MinusEqualsToken,
  "*=" => SyntaxKinds::AsteriskEqualsToken,
  "**=" => SyntaxKinds::AsteriskAsteriskEqualsToken,
  "/=" => SyntaxKinds::SlashEqualsToken,
  "%=" => SyntaxKinds::PercentEqualsToken,
  "<<=" => SyntaxKinds::LessThanLessThanEqualsToken,
  ">>=" => SyntaxKinds::GreaterThanGreaterThanEqualsToken,
  ">>>=" => SyntaxKinds::GreaterThanGreaterThanGreaterThanEqualsToken,
  "&=" => SyntaxKinds::AmpersandEqualsToken,
  "|=" => SyntaxKinds::BarEqualsToken,
  "^=" => SyntaxKinds::CaretEqualsToken,
  "||=" => SyntaxKinds::BarBarEqualsToken,
  "&&=" => SyntaxKinds::AmpersandAmpersandEqualsToken,
  "??=" => SyntaxKinds::QuestionQuestionEqualsToken,
  "@" => SyntaxKinds::AtToken,
  "`" => SyntaxKinds::BacktickToken,
};

static TOKEN_TO_STR: OnceCell<Vec<&'static str>> = OnceCell::new();

fn make_reverse_map(source: &Map<&'static str, u16>) -> Vec<&'static str> {
  let mut result: Vec<&'static str> = vec![""; source.len()];

  source.into_iter().for_each(|(&text, &token)| {
    result[token as usize] = text;
  });

  result
}

pub fn token_to_str(token: u16) -> Option<&'static str> {
  match TOKEN_TO_STR.get() {
    Some(map) => map.get(token as usize).copied(),
    None => {
      TOKEN_TO_STR.set(make_reverse_map(&STR_TO_TOKEN));
      token_to_str(token)
    }
  }
}

pub fn str_to_token(text: &str) -> Option<u16> {
  STR_TO_TOKEN.get(text).copied()
}
